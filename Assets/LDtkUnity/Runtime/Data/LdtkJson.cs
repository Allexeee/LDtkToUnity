// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using ldtk;
//
//    var ldtkJson = LdtkJson.FromJson(jsonString);

using System;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace LDtkUnity.Data
{
    public partial class LdtkJsonClass
    {
        /// <summary>
        /// Project background color
        /// </summary>
        [JsonProperty("bgColor")]
        public string BgColor { get; set; }

        /// <summary>
        /// Default grid size for new layers
        /// </summary>
        [JsonProperty("defaultGridSize")]
        public long DefaultGridSize { get; set; }

        /// <summary>
        /// Default background color of levels
        /// </summary>
        [JsonProperty("defaultLevelBgColor")]
        public string DefaultLevelBgColor { get; set; }

        /// <summary>
        /// Default X pivot (0 to 1) for new entities
        /// </summary>
        [JsonProperty("defaultPivotX")]
        public double DefaultPivotX { get; set; }

        /// <summary>
        /// Default Y pivot (0 to 1) for new entities
        /// </summary>
        [JsonProperty("defaultPivotY")]
        public double DefaultPivotY { get; set; }

        /// <summary>
        /// A structure containing all the definitions of this project
        /// </summary>
        [JsonProperty("defs")]
        public Definitions Defs { get; set; }

        /// <summary>
        /// If TRUE, a Tiled compatible file will also be generated along with the LDtk JSON file
        /// (default is FALSE)
        /// </summary>
        [JsonProperty("exportTiled")]
        public bool ExportTiled { get; set; }

        /// <summary>
        /// File format version
        /// </summary>
        [JsonProperty("jsonVersion")]
        public string JsonVersion { get; set; }

        /// <summary>
        /// All levels. The order of this array is only relevant in `LinearHorizontal` and
        /// `linearVertical` world layouts (see `worldLayout` value). Otherwise, you should refer to
        /// the `worldX`,`worldY` coordinates of each Level.
        /// </summary>
        [JsonProperty("levels")]
        public Level[] Levels { get; set; }

        /// <summary>
        /// If TRUE, the Json is partially minified (no indentation, nor line breaks, default is
        /// FALSE)
        /// </summary>
        [JsonProperty("minifyJson")]
        public bool MinifyJson { get; set; }

        [JsonProperty("nextUid")]
        public long NextUid { get; set; }

        /// <summary>
        /// Height of the world grid in pixels.
        /// </summary>
        [JsonProperty("worldGridHeight")]
        public long WorldGridHeight { get; set; }

        /// <summary>
        /// Width of the world grid in pixels.
        /// </summary>
        [JsonProperty("worldGridWidth")]
        public long WorldGridWidth { get; set; }

        /// <summary>
        /// An enum that describes how levels are organized in this project (ie. linearly or in a 2D
        /// space). Possible values are: Free, GridVania, LinearHorizontal and LinearVertical;
        /// </summary>
        [JsonProperty("worldLayout")]
        public string WorldLayout { get; set; }
    }

    public partial class DefinitionsClass
    {
        [JsonProperty("entities")]
        public EntityDef[] Entities { get; set; }

        [JsonProperty("enums")]
        public EnumDef[] Enums { get; set; }

        /// <summary>
        /// Note: external enums are exactly the same as `enums`, except they have a `relPath` to
        /// point to an external source file.
        /// </summary>
        [JsonProperty("externalEnums")]
        public EnumDef[] ExternalEnums { get; set; }

        [JsonProperty("layers")]
        public LayerDef[] Layers { get; set; }

        [JsonProperty("tilesets")]
        public TilesetDef[] Tilesets { get; set; }
    }

    public partial class EntityDefClass
    {
        /// <summary>
        /// Base entity color
        /// </summary>
        [JsonProperty("color")]
        public string Color { get; set; }

        /// <summary>
        /// Array of field definitions
        /// </summary>
        [JsonProperty("fieldDefs")]
        public FieldDef[] FieldDefs { get; set; }

        /// <summary>
        /// Pixel height
        /// </summary>
        [JsonProperty("height")]
        public long Height { get; set; }

        /// <summary>
        /// Unique String identifier
        /// </summary>
        [JsonProperty("identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Possible values: `DiscardOldOnes`, `PreventAdding`, `MoveLastOne`
        /// </summary>
        [JsonProperty("limitBehavior")]
        public EntityLimitBehavior LimitBehavior { get; set; }

        /// <summary>
        /// Max instances per level
        /// </summary>
        [JsonProperty("maxPerLevel")]
        public long MaxPerLevel { get; set; }

        /// <summary>
        /// Pivot X coordinate (from 0 to 1.0)
        /// </summary>
        [JsonProperty("pivotX")]
        public double PivotX { get; set; }

        /// <summary>
        /// Pivot Y coordinate (from 0 to 1.0)
        /// </summary>
        [JsonProperty("pivotY")]
        public double PivotY { get; set; }

        /// <summary>
        /// Possible values: `Rectangle`, `Ellipse`, `Tile`, `Cross`
        /// </summary>
        [JsonProperty("renderMode")]
        public EntityRenderMode RenderMode { get; set; }

        /// <summary>
        /// Display entity name in editor
        /// </summary>
        [JsonProperty("showName")]
        public bool ShowName { get; set; }

        /// <summary>
        /// Tile ID used for optional tile display
        /// </summary>
        [JsonProperty("tileId")]
        public long? TileId { get; set; }

        /// <summary>
        /// Possible values: `Stretch`, `Crop`
        /// </summary>
        [JsonProperty("tileRenderMode")]
        public EntityTileRenderMode TileRenderMode { get; set; }

        /// <summary>
        /// Tileset ID used for optional tile display
        /// </summary>
        [JsonProperty("tilesetId")]
        public long? TilesetId { get; set; }

        /// <summary>
        /// Unique Int identifier
        /// </summary>
        [JsonProperty("uid")]
        public long Uid { get; set; }

        /// <summary>
        /// Pixel width
        /// </summary>
        [JsonProperty("width")]
        public long Width { get; set; }
    }

    public partial class FieldDefClass
    {
        /// <summary>
        /// Human readable value type (eg. `Int`, `Float`, `Point`, etc.). If the field is an array,
        /// this field will look like `Array<...>` (eg. `Array<Int>`, `Array<Point>` etc.)
        /// </summary>
        [JsonProperty("__type")]
        public string Type { get; set; }

        /// <summary>
        /// Optional list of accepted file extensions for FilePath value type. Includes the dot:
        /// `.ext`
        /// </summary>
        [JsonProperty("acceptFileTypes")]
        public string[] AcceptFileTypes { get; set; }

        /// <summary>
        /// Array max length
        /// </summary>
        [JsonProperty("arrayMaxLength")]
        public long? ArrayMaxLength { get; set; }

        /// <summary>
        /// Array min length
        /// </summary>
        [JsonProperty("arrayMinLength")]
        public long? ArrayMinLength { get; set; }

        /// <summary>
        /// TRUE if the value can be null. For arrays, TRUE means it can contain null values
        /// (exception: array of Points can't have null values).
        /// </summary>
        [JsonProperty("canBeNull")]
        public bool CanBeNull { get; set; }

        /// <summary>
        /// Default value if selected value is null or invalid.
        /// </summary>
        [JsonProperty("defaultOverride")]
        public dynamic DefaultOverride { get; set; }

        [JsonProperty("editorAlwaysShow")]
        public bool EditorAlwaysShow { get; set; }

        /// <summary>
        /// Possible values: `Hidden`, `ValueOnly`, `NameAndValue`, `EntityTile`, `PointStar`,
        /// `PointPath`, `RadiusPx`, `RadiusGrid`
        /// </summary>
        [JsonProperty("editorDisplayMode")]
        public FieldDisplayMode EditorDisplayMode { get; set; }

        /// <summary>
        /// Possible values: `Above`, `Center`, `Beneath`
        /// </summary>
        [JsonProperty("editorDisplayPos")]
        public FieldDisplayPosition EditorDisplayPos { get; set; }

        /// <summary>
        /// Unique String identifier
        /// </summary>
        [JsonProperty("identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// TRUE if the value is an array of multiple values
        /// </summary>
        [JsonProperty("isArray")]
        public bool IsArray { get; set; }

        /// <summary>
        /// Max limit for value, if applicable
        /// </summary>
        [JsonProperty("max")]
        public double? Max { get; set; }

        /// <summary>
        /// Min limit for value, if applicable
        /// </summary>
        [JsonProperty("min")]
        public double? Min { get; set; }

        /// <summary>
        /// Optional regular expression that needs to be matched to accept values. Expected format:
        /// `/some_reg_ex/g`, with optional "i" flag.
        /// </summary>
        [JsonProperty("regex")]
        public string Regex { get; set; }

        /// <summary>
        /// Internal type enum
        /// </summary>
        [JsonProperty("type")]
        public dynamic FieldDefType { get; set; }

        /// <summary>
        /// Unique Intidentifier
        /// </summary>
        [JsonProperty("uid")]
        public long Uid { get; set; }
    }

    public partial class EnumDefClass
    {
        [JsonProperty("externalFileChecksum")]
        public string ExternalFileChecksum { get; set; }

        /// <summary>
        /// Relative path to the external file providing this Enum
        /// </summary>
        [JsonProperty("externalRelPath")]
        public string ExternalRelPath { get; set; }

        /// <summary>
        /// Tileset UID if provided
        /// </summary>
        [JsonProperty("iconTilesetUid")]
        public long? IconTilesetUid { get; set; }

        /// <summary>
        /// Unique String identifier
        /// </summary>
        [JsonProperty("identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Unique Int identifier
        /// </summary>
        [JsonProperty("uid")]
        public long Uid { get; set; }

        /// <summary>
        /// All possible enum values, with their optional Tile infos.
        /// </summary>
        [JsonProperty("values")]
        public Value[] Values { get; set; }
    }

    public partial class Value
    {
        [JsonProperty("__tileSrcRect", NullValueHandling = NullValueHandling.Ignore)]
        public long[] TileSrcRect { get; set; }

        [JsonProperty("id", NullValueHandling = NullValueHandling.Ignore)]
        public string Id { get; set; }

        [JsonProperty("tileId")]
        public long? TileId { get; set; }
    }

    public partial class LayerDefClass
    {
        /// <summary>
        /// Type of the layer (*IntGrid, Entities, Tiles or AutoLayer*)
        /// </summary>
        [JsonProperty("__type")]
        public string Type { get; set; }

        /// <summary>
        /// Contains all the auto-layer rule definitions.
        /// </summary>
        [JsonProperty("autoRuleGroups")]
        public AutoRuleGroup[] AutoRuleGroups { get; set; }

        [JsonProperty("autoSourceLayerDefUid")]
        public long? AutoSourceLayerDefUid { get; set; }

        /// <summary>
        /// Reference to the Tileset UID being used by this auto-layer rules
        /// </summary>
        [JsonProperty("autoTilesetDefUid")]
        public long? AutoTilesetDefUid { get; set; }

        /// <summary>
        /// Opacity of the layer (0 to 1.0)
        /// </summary>
        [JsonProperty("displayOpacity")]
        public double DisplayOpacity { get; set; }

        /// <summary>
        /// Width and height of the grid in pixels
        /// </summary>
        [JsonProperty("gridSize")]
        public long GridSize { get; set; }

        /// <summary>
        /// Unique String identifier
        /// </summary>
        [JsonProperty("identifier")]
        public string Identifier { get; set; }

        [JsonProperty("intGridValues")]
        public IntGridValue[] IntGridValues { get; set; }

        /// <summary>
        /// X offset of the layer, in pixels (IMPORTANT: this should be added to the `LayerInstance`
        /// optional offset)
        /// </summary>
        [JsonProperty("pxOffsetX")]
        public long PxOffsetX { get; set; }

        /// <summary>
        /// Y offset of the layer, in pixels (IMPORTANT: this should be added to the `LayerInstance`
        /// optional offset)
        /// </summary>
        [JsonProperty("pxOffsetY")]
        public long PxOffsetY { get; set; }

        /// <summary>
        /// If the tiles are smaller or larger than the layer grid, the pivot value will be used to
        /// position the tile relatively its grid cell.
        /// </summary>
        [JsonProperty("tilePivotX")]
        public double TilePivotX { get; set; }

        /// <summary>
        /// If the tiles are smaller or larger than the layer grid, the pivot value will be used to
        /// position the tile relatively its grid cell.
        /// </summary>
        [JsonProperty("tilePivotY")]
        public double TilePivotY { get; set; }

        /// <summary>
        /// Reference to the Tileset UID being used by this tile layer
        /// </summary>
        [JsonProperty("tilesetDefUid")]
        public long? TilesetDefUid { get; set; }

        /// <summary>
        /// Type of the layer as Haxe Enum Possible values: `IntGrid`, `Entities`, `Tiles`,
        /// `AutoLayer`
        /// </summary>
        [JsonProperty("type")]
        public LayerType LayerDefType { get; set; }

        /// <summary>
        /// Unique Int identifier
        /// </summary>
        [JsonProperty("uid")]
        public long Uid { get; set; }
    }

    public partial class AutoRuleGroup
    {
        [JsonProperty("active", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Active { get; set; }

        [JsonProperty("collapsed", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Collapsed { get; set; }

        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        [JsonProperty("rules", NullValueHandling = NullValueHandling.Ignore)]
        public AutoRuleDef[] Rules { get; set; }

        [JsonProperty("uid", NullValueHandling = NullValueHandling.Ignore)]
        public long? Uid { get; set; }
    }

    public partial class AutoRuleDefClass
    {
        /// <summary>
        /// If FALSE, the rule effect isn't applied, and no tiles are generated.
        /// </summary>
        [JsonProperty("active")]
        public bool Active { get; set; }

        /// <summary>
        /// When TRUE, the rule will prevent other rules to be applied in the same cell if it matches
        /// (TRUE by default).
        /// </summary>
        [JsonProperty("breakOnMatch")]
        public bool BreakOnMatch { get; set; }

        /// <summary>
        /// Chances for this rule to be applied (0 to 1)
        /// </summary>
        [JsonProperty("chance")]
        public double Chance { get; set; }

        /// <summary>
        /// Checker mode Possible values: `None`, `Horizontal`, `Vertical`
        /// </summary>
        [JsonProperty("checker")]
        public AutoLayerRuleCheckerMode Checker { get; set; }

        /// <summary>
        /// If TRUE, allow rule to be matched by flipping its pattern horizontally
        /// </summary>
        [JsonProperty("flipX")]
        public bool FlipX { get; set; }

        /// <summary>
        /// If TRUE, allow rule to be matched by flipping its pattern vertically
        /// </summary>
        [JsonProperty("flipY")]
        public bool FlipY { get; set; }

        /// <summary>
        /// Rule pattern (size x size)
        /// </summary>
        [JsonProperty("pattern")]
        public long[] Pattern { get; set; }

        /// <summary>
        /// If TRUE, enable Perlin filtering to only apply rule on specific random area
        /// </summary>
        [JsonProperty("perlinActive")]
        public bool PerlinActive { get; set; }

        [JsonProperty("perlinOctaves")]
        public double PerlinOctaves { get; set; }

        [JsonProperty("perlinScale")]
        public double PerlinScale { get; set; }

        [JsonProperty("perlinSeed")]
        public double PerlinSeed { get; set; }

        /// <summary>
        /// X pivot of a tile stamp (0-1)
        /// </summary>
        [JsonProperty("pivotX")]
        public double PivotX { get; set; }

        /// <summary>
        /// Y pivot of a tile stamp (0-1)
        /// </summary>
        [JsonProperty("pivotY")]
        public double PivotY { get; set; }

        /// <summary>
        /// Pattern width & height. Should only be 1,3,5 or 7.
        /// </summary>
        [JsonProperty("size")]
        public long Size { get; set; }

        /// <summary>
        /// Array of all the tile IDs. They are used randomly or as stamps, based on `tileMode` value.
        /// </summary>
        [JsonProperty("tileIds")]
        public long[] TileIds { get; set; }

        /// <summary>
        /// Defines how tileIds array is used Possible values: `Single`, `Stamp`
        /// </summary>
        [JsonProperty("tileMode")]
        public AutoLayerRuleTileMode TileMode { get; set; }

        /// <summary>
        /// Unique Int identifier
        /// </summary>
        [JsonProperty("uid")]
        public long Uid { get; set; }

        /// <summary>
        /// X cell coord modulo
        /// </summary>
        [JsonProperty("xModulo")]
        public long XModulo { get; set; }

        /// <summary>
        /// Y cell coord modulo
        /// </summary>
        [JsonProperty("yModulo")]
        public long YModulo { get; set; }
    }

    public partial class IntGridValue
    {
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public string Color { get; set; }

        [JsonProperty("identifier")]
        public string Identifier { get; set; }
    }

    public partial class TilesetDefClass
    {
        /// <summary>
        /// The following data is used internally for various optimizations. It's always synced with
        /// source image changes.
        /// </summary>
        [JsonProperty("cachedPixelData")]
        public CachedPixelData CachedPixelData { get; set; }

        /// <summary>
        /// Unique String identifier
        /// </summary>
        [JsonProperty("identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Distance in pixels from image borders
        /// </summary>
        [JsonProperty("padding")]
        public long Padding { get; set; }

        /// <summary>
        /// Image height in pixels
        /// </summary>
        [JsonProperty("pxHei")]
        public long PxHei { get; set; }

        /// <summary>
        /// Image width in pixels
        /// </summary>
        [JsonProperty("pxWid")]
        public long PxWid { get; set; }

        /// <summary>
        /// Path to the source file, relative to the current project JSON file
        /// </summary>
        [JsonProperty("relPath")]
        public string RelPath { get; set; }

        /// <summary>
        /// Array of group of tiles selections, only meant to be used in the editor
        /// </summary>
        [JsonProperty("savedSelections")]
        public SavedSelection[] SavedSelections { get; set; }

        /// <summary>
        /// Space in pixels between all tiles
        /// </summary>
        [JsonProperty("spacing")]
        public long Spacing { get; set; }

        [JsonProperty("tileGridSize")]
        public long TileGridSize { get; set; }

        /// <summary>
        /// Unique Intidentifier
        /// </summary>
        [JsonProperty("uid")]
        public long Uid { get; set; }
    }

    public partial class CachedPixelData
    {
        [JsonProperty("averageColors")]
        public string AverageColors { get; set; }

        [JsonProperty("opaqueTiles", NullValueHandling = NullValueHandling.Ignore)]
        public string OpaqueTiles { get; set; }
    }

    public partial class SavedSelection
    {
        [JsonProperty("ids", NullValueHandling = NullValueHandling.Ignore)]
        public long[] Ids { get; set; }

        [JsonProperty("mode")]
        public dynamic Mode { get; set; }
    }

    public partial class LevelClass
    {
        /// <summary>
        /// Background color of the level (same as `bgColor`, except the default value is
        /// automatically used here if its value is `null`)
        /// </summary>
        [JsonProperty("__bgColor")]
        public string BgColor { get; set; }

        /// <summary>
        /// An array listing all other levels touching this one on the world map. The `dir` is a
        /// single lowercase character tipping on the level location (`n`orth, `s`outh, `w`est,
        /// `e`ast). In "linear" world layouts, this array is populated with previous/next levels in
        /// array, and `dir` depends on the linear horizontal/vertical layout.
        /// </summary>
        [JsonProperty("__neighbours")]
        public Neighbour[] Neighbours { get; set; }

        /// <summary>
        /// Background color of the level. If `null`, the project `defaultLevelBgColor` should be
        /// used.
        /// </summary>
        [JsonProperty("bgColor")]
        public string LevelBgColor { get; set; }

        /// <summary>
        /// Unique String identifier
        /// </summary>
        [JsonProperty("identifier")]
        public string Identifier { get; set; }

        [JsonProperty("layerInstances")]
        public LayerInstance[] LayerInstances { get; set; }

        /// <summary>
        /// Height of the level in pixels
        /// </summary>
        [JsonProperty("pxHei")]
        public long PxHei { get; set; }

        /// <summary>
        /// Width of the level in pixels
        /// </summary>
        [JsonProperty("pxWid")]
        public long PxWid { get; set; }

        /// <summary>
        /// Unique Int identifier
        /// </summary>
        [JsonProperty("uid")]
        public long Uid { get; set; }

        /// <summary>
        /// World X coordinate in pixels
        /// </summary>
        [JsonProperty("worldX")]
        public long WorldX { get; set; }

        /// <summary>
        /// World Y coordinate in pixels
        /// </summary>
        [JsonProperty("worldY")]
        public long WorldY { get; set; }
    }

    public partial class LayerInstanceClass
    {
        /// <summary>
        /// Grid-based height
        /// </summary>
        [JsonProperty("__cHei")]
        public long CHei { get; set; }

        /// <summary>
        /// Grid-based width
        /// </summary>
        [JsonProperty("__cWid")]
        public long CWid { get; set; }

        /// <summary>
        /// Grid size
        /// </summary>
        [JsonProperty("__gridSize")]
        public long GridSize { get; set; }

        /// <summary>
        /// Unique String identifier
        /// </summary>
        [JsonProperty("__identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Layer opacity as Float [0-1]
        /// </summary>
        [JsonProperty("__opacity")]
        public double Opacity { get; set; }

        /// <summary>
        /// Total layer X pixel offset, including both instance and definition offsets.
        /// </summary>
        [JsonProperty("__pxTotalOffsetX")]
        public long PxTotalOffsetX { get; set; }

        /// <summary>
        /// Total layer Y pixel offset, including both instance and definition offsets.
        /// </summary>
        [JsonProperty("__pxTotalOffsetY")]
        public long PxTotalOffsetY { get; set; }

        /// <summary>
        /// The definition UID of corresponding Tileset, if any.
        /// </summary>
        [JsonProperty("__tilesetDefUid")]
        public long? TilesetDefUid { get; set; }

        /// <summary>
        /// The relative path to corresponding Tileset, if any.
        /// </summary>
        [JsonProperty("__tilesetRelPath")]
        public string TilesetRelPath { get; set; }

        /// <summary>
        /// Layer type (possible values: IntGrid, Entities, Tiles or AutoLayer)
        /// </summary>
        [JsonProperty("__type")]
        public string Type { get; set; }

        /// <summary>
        /// An array containing all tiles generated by Auto-layer rules. The array is already sorted
        /// in display order (ie. 1st tile is beneath 2nd, which is beneath 3rd etc.).<br/><br/>
        /// Note: if multiple tiles are stacked in the same cell as the result of different rules,
        /// all tiles behind opaque ones will be discarded.
        /// </summary>
        [JsonProperty("autoLayerTiles")]
        public Tile[] AutoLayerTiles { get; set; }

        [JsonProperty("entityInstances")]
        public EntityInstance[] EntityInstances { get; set; }

        [JsonProperty("gridTiles")]
        public Tile[] GridTiles { get; set; }

        [JsonProperty("intGrid")]
        public IntGrid[] IntGrid { get; set; }

        /// <summary>
        /// Reference the Layer definition UID
        /// </summary>
        [JsonProperty("layerDefUid")]
        public long LayerDefUid { get; set; }

        /// <summary>
        /// Reference to the UID of the level containing this layer instance
        /// </summary>
        [JsonProperty("levelId")]
        public long LevelId { get; set; }

        /// <summary>
        /// X offset in pixels to render this layer, usually 0 (IMPORTANT: this should be added to
        /// the `LayerDef` optional offset, see `__pxTotalOffsetX`)
        /// </summary>
        [JsonProperty("pxOffsetX")]
        public long PxOffsetX { get; set; }

        /// <summary>
        /// Y offset in pixels to render this layer, usually 0 (IMPORTANT: this should be added to
        /// the `LayerDef` optional offset, see `__pxTotalOffsetY`)
        /// </summary>
        [JsonProperty("pxOffsetY")]
        public long PxOffsetY { get; set; }

        /// <summary>
        /// Random seed used for Auto-Layers rendering
        /// </summary>
        [JsonProperty("seed")]
        public long Seed { get; set; }
    }

    public partial class TileClass
    {
        /// <summary>
        /// Internal data used by the editor.<br/>  For auto-layer tiles: `[ruleId, coordId]`.<br/>
        /// For tile-layer tiles: `[coordId]`.
        /// </summary>
        [JsonProperty("d")]
        public long[] D { get; set; }

        /// <summary>
        /// "Flip bits", a 2-bits integer to represent the mirror transformations of the tile.<br/>
        /// - Bit 0 = X flip<br/>   - Bit 1 = Y flip<br/>   Examples: f=0 (no flip), f=1 (X flip
        /// only), f=2 (Y flip only), f=3 (both flips)
        /// </summary>
        [JsonProperty("f")]
        public long F { get; set; }

        /// <summary>
        /// Pixel coordinates of the tile in the **layer** (`[x,y]` format). Don't forget optional
        /// layer offsets, if they exist!
        /// </summary>
        [JsonProperty("px")]
        public long[] Px { get; set; }

        /// <summary>
        /// Pixel coordinates of the tile in the **tileset** (`[x,y]` format)
        /// </summary>
        [JsonProperty("src")]
        public long[] Src { get; set; }

        /// <summary>
        /// The *Tile ID* in the corresponding tileset.
        /// </summary>
        [JsonProperty("t")]
        public long T { get; set; }
    }

    public partial class EntityInstanceClass
    {
        /// <summary>
        /// Grid-based coordinates (`[x,y]` format)
        /// </summary>
        [JsonProperty("__grid")]
        public long[] Grid { get; set; }

        /// <summary>
        /// Unique String identifier
        /// </summary>
        [JsonProperty("__identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Optional Tile used to display this entity (it could either be the default Entity tile, or
        /// some tile provided by a field value, like an Enum).
        /// </summary>
        [JsonProperty("__tile")]
        public EntityInstanceTile Tile { get; set; }

        /// <summary>
        /// Reference of the **Entity definition** UID
        /// </summary>
        [JsonProperty("defUid")]
        public long DefUid { get; set; }

        [JsonProperty("fieldInstances")]
        public FieldInstance[] FieldInstances { get; set; }

        /// <summary>
        /// Pixel coordinates (`[x,y]` format). Don't forget optional layer offsets, if they exist!
        /// </summary>
        [JsonProperty("px")]
        public long[] Px { get; set; }
    }

    public partial class FieldInstanceClass
    {
        /// <summary>
        /// Unique String identifier
        /// </summary>
        [JsonProperty("__identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Type of the field, such as Int, Float, Enum(enum_name), Bool, etc.
        /// </summary>
        [JsonProperty("__type")]
        public string Type { get; set; }

        /// <summary>
        /// Actual value of the field instance. The value type may vary, depending on `__type`
        /// (Integer, Boolean, String etc.)<br/>  It can also be an `Array` of various types.
        /// </summary>
        [JsonProperty("__value")]
        public dynamic Value { get; set; }

        /// <summary>
        /// Reference of the **Field definition** UID
        /// </summary>
        [JsonProperty("defUid")]
        public long DefUid { get; set; }

        [JsonProperty("realEditorValues")]
        public dynamic[] RealEditorValues { get; set; }
    }

    public partial class EntityInstanceTile
    {
        [JsonProperty("srcRect", NullValueHandling = NullValueHandling.Ignore)]
        public long[] SrcRect { get; set; }

        [JsonProperty("tilesetUid", NullValueHandling = NullValueHandling.Ignore)]
        public long? TilesetUid { get; set; }
    }

    public partial class IntGrid
    {
        [JsonProperty("coordId", NullValueHandling = NullValueHandling.Ignore)]
        public long? CoordId { get; set; }

        [JsonProperty("v", NullValueHandling = NullValueHandling.Ignore)]
        public long? V { get; set; }
    }

    public partial class Neighbour
    {
        [JsonProperty("dir", NullValueHandling = NullValueHandling.Ignore)]
        public string Dir { get; set; }

        [JsonProperty("levelUid", NullValueHandling = NullValueHandling.Ignore)]
        public long? LevelUid { get; set; }
    }

    /// <summary>
    /// Possible values: `Hidden`, `ValueOnly`, `NameAndValue`, `EntityTile`, `PointStar`,
    /// `PointPath`, `RadiusPx`, `RadiusGrid`
    /// </summary>
    public enum FieldDisplayMode { EntityTile, Hidden, NameAndValue, PointPath, PointStar, RadiusGrid, RadiusPx, ValueOnly };

    /// <summary>
    /// Possible values: `Above`, `Center`, `Beneath`
    /// </summary>
    public enum FieldDisplayPosition { Above, Beneath, Center };

    /// <summary>
    /// Possible values: `DiscardOldOnes`, `PreventAdding`, `MoveLastOne`
    /// </summary>
    public enum EntityLimitBehavior { DiscardOldOnes, MoveLastOne, PreventAdding };

    /// <summary>
    /// Possible values: `Rectangle`, `Ellipse`, `Tile`, `Cross`
    /// </summary>
    public enum EntityRenderMode { Cross, Ellipse, Rectangle, Tile };

    /// <summary>
    /// Possible values: `Stretch`, `Crop`
    /// </summary>
    public enum EntityTileRenderMode { Crop, Stretch };

    /// <summary>
    /// Checker mode Possible values: `None`, `Horizontal`, `Vertical`
    /// </summary>
    public enum AutoLayerRuleCheckerMode { Horizontal, None, Vertical };

    /// <summary>
    /// Defines how tileIds array is used Possible values: `Single`, `Stamp`
    /// </summary>
    public enum AutoLayerRuleTileMode { Single, Stamp };

    /// <summary>
    /// Type of the layer as Haxe Enum Possible values: `IntGrid`, `Entities`, `Tiles`,
    /// `AutoLayer`
    /// </summary>
    public enum LayerType { AutoLayer, Entities, IntGrid, Tiles };

    public partial struct FieldDef
    {
        public dynamic[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public FieldDefClass FieldDefClass;
        public long? Integer;
        public string String;

        public static implicit operator FieldDef(dynamic[] AnythingArray) => new FieldDef { AnythingArray = AnythingArray };
        public static implicit operator FieldDef(bool Bool) => new FieldDef { Bool = Bool };
        public static implicit operator FieldDef(double Double) => new FieldDef { Double = Double };
        public static implicit operator FieldDef(FieldDefClass FieldDefClass) => new FieldDef { FieldDefClass = FieldDefClass };
        public static implicit operator FieldDef(long Integer) => new FieldDef { Integer = Integer };
        public static implicit operator FieldDef(string String) => new FieldDef { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && FieldDefClass == null && Double == null && Integer == null && String == null;
    }

    public partial struct EntityDef
    {
        public dynamic[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public EntityDefClass EntityDefClass;
        public long? Integer;
        public string String;

        public static implicit operator EntityDef(dynamic[] AnythingArray) => new EntityDef { AnythingArray = AnythingArray };
        public static implicit operator EntityDef(bool Bool) => new EntityDef { Bool = Bool };
        public static implicit operator EntityDef(double Double) => new EntityDef { Double = Double };
        public static implicit operator EntityDef(EntityDefClass EntityDefClass) => new EntityDef { EntityDefClass = EntityDefClass };
        public static implicit operator EntityDef(long Integer) => new EntityDef { Integer = Integer };
        public static implicit operator EntityDef(string String) => new EntityDef { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && EntityDefClass == null && Double == null && Integer == null && String == null;
    }

    public partial struct EnumDef
    {
        public dynamic[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public EnumDefClass EnumDefClass;
        public long? Integer;
        public string String;

        public static implicit operator EnumDef(dynamic[] AnythingArray) => new EnumDef { AnythingArray = AnythingArray };
        public static implicit operator EnumDef(bool Bool) => new EnumDef { Bool = Bool };
        public static implicit operator EnumDef(double Double) => new EnumDef { Double = Double };
        public static implicit operator EnumDef(EnumDefClass EnumDefClass) => new EnumDef { EnumDefClass = EnumDefClass };
        public static implicit operator EnumDef(long Integer) => new EnumDef { Integer = Integer };
        public static implicit operator EnumDef(string String) => new EnumDef { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && EnumDefClass == null && Double == null && Integer == null && String == null;
    }

    public partial struct AutoRuleDef
    {
        public dynamic[] AnythingArray;
        public AutoRuleDefClass AutoRuleDefClass;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public string String;

        public static implicit operator AutoRuleDef(dynamic[] AnythingArray) => new AutoRuleDef { AnythingArray = AnythingArray };
        public static implicit operator AutoRuleDef(AutoRuleDefClass AutoRuleDefClass) => new AutoRuleDef { AutoRuleDefClass = AutoRuleDefClass };
        public static implicit operator AutoRuleDef(bool Bool) => new AutoRuleDef { Bool = Bool };
        public static implicit operator AutoRuleDef(double Double) => new AutoRuleDef { Double = Double };
        public static implicit operator AutoRuleDef(long Integer) => new AutoRuleDef { Integer = Integer };
        public static implicit operator AutoRuleDef(string String) => new AutoRuleDef { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && AutoRuleDefClass == null && Double == null && Integer == null && String == null;
    }

    public partial struct LayerDef
    {
        public dynamic[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public LayerDefClass LayerDefClass;
        public string String;

        public static implicit operator LayerDef(dynamic[] AnythingArray) => new LayerDef { AnythingArray = AnythingArray };
        public static implicit operator LayerDef(bool Bool) => new LayerDef { Bool = Bool };
        public static implicit operator LayerDef(double Double) => new LayerDef { Double = Double };
        public static implicit operator LayerDef(long Integer) => new LayerDef { Integer = Integer };
        public static implicit operator LayerDef(LayerDefClass LayerDefClass) => new LayerDef { LayerDefClass = LayerDefClass };
        public static implicit operator LayerDef(string String) => new LayerDef { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && LayerDefClass == null && Double == null && Integer == null && String == null;
    }

    public partial struct TilesetDef
    {
        public dynamic[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public string String;
        public TilesetDefClass TilesetDefClass;

        public static implicit operator TilesetDef(dynamic[] AnythingArray) => new TilesetDef { AnythingArray = AnythingArray };
        public static implicit operator TilesetDef(bool Bool) => new TilesetDef { Bool = Bool };
        public static implicit operator TilesetDef(double Double) => new TilesetDef { Double = Double };
        public static implicit operator TilesetDef(long Integer) => new TilesetDef { Integer = Integer };
        public static implicit operator TilesetDef(string String) => new TilesetDef { String = String };
        public static implicit operator TilesetDef(TilesetDefClass TilesetDefClass) => new TilesetDef { TilesetDefClass = TilesetDefClass };
        public bool IsNull => AnythingArray == null && Bool == null && TilesetDefClass == null && Double == null && Integer == null && String == null;
    }

    /// <summary>
    /// A structure containing all the definitions of this project
    /// </summary>
    public partial struct Definitions
    {
        public dynamic[] AnythingArray;
        public bool? Bool;
        public DefinitionsClass DefinitionsClass;
        public double? Double;
        public long? Integer;
        public string String;

        public static implicit operator Definitions(dynamic[] AnythingArray) => new Definitions { AnythingArray = AnythingArray };
        public static implicit operator Definitions(bool Bool) => new Definitions { Bool = Bool };
        public static implicit operator Definitions(DefinitionsClass DefinitionsClass) => new Definitions { DefinitionsClass = DefinitionsClass };
        public static implicit operator Definitions(double Double) => new Definitions { Double = Double };
        public static implicit operator Definitions(long Integer) => new Definitions { Integer = Integer };
        public static implicit operator Definitions(string String) => new Definitions { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && DefinitionsClass == null && Double == null && Integer == null && String == null;
    }

    public partial struct Tile
    {
        public dynamic[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public string String;
        public TileClass TileClass;

        public static implicit operator Tile(dynamic[] AnythingArray) => new Tile { AnythingArray = AnythingArray };
        public static implicit operator Tile(bool Bool) => new Tile { Bool = Bool };
        public static implicit operator Tile(double Double) => new Tile { Double = Double };
        public static implicit operator Tile(long Integer) => new Tile { Integer = Integer };
        public static implicit operator Tile(string String) => new Tile { String = String };
        public static implicit operator Tile(TileClass TileClass) => new Tile { TileClass = TileClass };
        public bool IsNull => AnythingArray == null && Bool == null && TileClass == null && Double == null && Integer == null && String == null;
    }

    public partial struct FieldInstance
    {
        public dynamic[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public FieldInstanceClass FieldInstanceClass;
        public long? Integer;
        public string String;

        public static implicit operator FieldInstance(dynamic[] AnythingArray) => new FieldInstance { AnythingArray = AnythingArray };
        public static implicit operator FieldInstance(bool Bool) => new FieldInstance { Bool = Bool };
        public static implicit operator FieldInstance(double Double) => new FieldInstance { Double = Double };
        public static implicit operator FieldInstance(FieldInstanceClass FieldInstanceClass) => new FieldInstance { FieldInstanceClass = FieldInstanceClass };
        public static implicit operator FieldInstance(long Integer) => new FieldInstance { Integer = Integer };
        public static implicit operator FieldInstance(string String) => new FieldInstance { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && FieldInstanceClass == null && Double == null && Integer == null && String == null;
    }

    public partial struct EntityInstance
    {
        public dynamic[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public EntityInstanceClass EntityInstanceClass;
        public long? Integer;
        public string String;

        public static implicit operator EntityInstance(dynamic[] AnythingArray) => new EntityInstance { AnythingArray = AnythingArray };
        public static implicit operator EntityInstance(bool Bool) => new EntityInstance { Bool = Bool };
        public static implicit operator EntityInstance(double Double) => new EntityInstance { Double = Double };
        public static implicit operator EntityInstance(EntityInstanceClass EntityInstanceClass) => new EntityInstance { EntityInstanceClass = EntityInstanceClass };
        public static implicit operator EntityInstance(long Integer) => new EntityInstance { Integer = Integer };
        public static implicit operator EntityInstance(string String) => new EntityInstance { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && EntityInstanceClass == null && Double == null && Integer == null && String == null;
    }

    public partial struct LayerInstance
    {
        public dynamic[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public LayerInstanceClass LayerInstanceClass;
        public string String;

        public static implicit operator LayerInstance(dynamic[] AnythingArray) => new LayerInstance { AnythingArray = AnythingArray };
        public static implicit operator LayerInstance(bool Bool) => new LayerInstance { Bool = Bool };
        public static implicit operator LayerInstance(double Double) => new LayerInstance { Double = Double };
        public static implicit operator LayerInstance(long Integer) => new LayerInstance { Integer = Integer };
        public static implicit operator LayerInstance(LayerInstanceClass LayerInstanceClass) => new LayerInstance { LayerInstanceClass = LayerInstanceClass };
        public static implicit operator LayerInstance(string String) => new LayerInstance { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && LayerInstanceClass == null && Double == null && Integer == null && String == null;
    }

    public partial struct Level
    {
        public dynamic[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public LevelClass LevelClass;
        public string String;

        public static implicit operator Level(dynamic[] AnythingArray) => new Level { AnythingArray = AnythingArray };
        public static implicit operator Level(bool Bool) => new Level { Bool = Bool };
        public static implicit operator Level(double Double) => new Level { Double = Double };
        public static implicit operator Level(long Integer) => new Level { Integer = Integer };
        public static implicit operator Level(LevelClass LevelClass) => new Level { LevelClass = LevelClass };
        public static implicit operator Level(string String) => new Level { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && LevelClass == null && Double == null && Integer == null && String == null;
    }

    public partial struct LdtkJsonUnion
    {
        public dynamic[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public LdtkJsonClass LdtkJsonClass;
        public string String;

        public static implicit operator LdtkJsonUnion(dynamic[] AnythingArray) => new LdtkJsonUnion { AnythingArray = AnythingArray };
        public static implicit operator LdtkJsonUnion(bool Bool) => new LdtkJsonUnion { Bool = Bool };
        public static implicit operator LdtkJsonUnion(double Double) => new LdtkJsonUnion { Double = Double };
        public static implicit operator LdtkJsonUnion(long Integer) => new LdtkJsonUnion { Integer = Integer };
        public static implicit operator LdtkJsonUnion(LdtkJsonClass LdtkJsonClass) => new LdtkJsonUnion { LdtkJsonClass = LdtkJsonClass };
        public static implicit operator LdtkJsonUnion(string String) => new LdtkJsonUnion { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && LdtkJsonClass == null && Double == null && Integer == null && String == null;
    }

    public class LdtkJson
    {
        public static LdtkJsonClass FromJson(string json) => JsonConvert.DeserializeObject<LdtkJsonClass>(json, Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this object self) => JsonConvert.SerializeObject(self, Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                LdtkJsonUnionConverter.Singleton,
                DefinitionsConverter.Singleton,
                EntityDefConverter.Singleton,
                FieldDefConverter.Singleton,
                FieldDisplayModeConverter.Singleton,
                FieldDisplayPositionConverter.Singleton,
                EntityLimitBehaviorConverter.Singleton,
                EntityRenderModeConverter.Singleton,
                EntityTileRenderModeConverter.Singleton,
                EnumDefConverter.Singleton,
                LayerDefConverter.Singleton,
                AutoRuleDefConverter.Singleton,
                AutoLayerRuleCheckerModeConverter.Singleton,
                AutoLayerRuleTileModeConverter.Singleton,
                LayerTypeConverter.Singleton,
                TilesetDefConverter.Singleton,
                LevelConverter.Singleton,
                LayerInstanceConverter.Singleton,
                TileConverter.Singleton,
                EntityInstanceConverter.Singleton,
                FieldInstanceConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class LdtkJsonUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LdtkJsonUnion) || t == typeof(LdtkJsonUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new LdtkJsonUnion { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new LdtkJsonUnion { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new LdtkJsonUnion { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new LdtkJsonUnion { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new LdtkJsonUnion { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<LdtkJsonClass>(reader);
                    return new LdtkJsonUnion { LdtkJsonClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<dynamic[]>(reader);
                    return new LdtkJsonUnion { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type LdtkJsonUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (LdtkJsonUnion)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.LdtkJsonClass != null)
            {
                serializer.Serialize(writer, value.LdtkJsonClass);
                return;
            }
            throw new Exception("Cannot marshal type LdtkJsonUnion");
        }

        public static readonly LdtkJsonUnionConverter Singleton = new LdtkJsonUnionConverter();
    }

    internal class DefinitionsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Definitions) || t == typeof(Definitions?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new Definitions { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new Definitions { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Definitions { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Definitions { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Definitions { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DefinitionsClass>(reader);
                    return new Definitions { DefinitionsClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<dynamic[]>(reader);
                    return new Definitions { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Definitions");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Definitions)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.DefinitionsClass != null)
            {
                serializer.Serialize(writer, value.DefinitionsClass);
                return;
            }
            throw new Exception("Cannot marshal type Definitions");
        }

        public static readonly DefinitionsConverter Singleton = new DefinitionsConverter();
    }

    internal class EntityDefConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EntityDef) || t == typeof(EntityDef?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new EntityDef { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new EntityDef { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new EntityDef { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new EntityDef { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new EntityDef { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<EntityDefClass>(reader);
                    return new EntityDef { EntityDefClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<dynamic[]>(reader);
                    return new EntityDef { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type EntityDef");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (EntityDef)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.EntityDefClass != null)
            {
                serializer.Serialize(writer, value.EntityDefClass);
                return;
            }
            throw new Exception("Cannot marshal type EntityDef");
        }

        public static readonly EntityDefConverter Singleton = new EntityDefConverter();
    }

    internal class FieldDefConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FieldDef) || t == typeof(FieldDef?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new FieldDef { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new FieldDef { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new FieldDef { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new FieldDef { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new FieldDef { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FieldDefClass>(reader);
                    return new FieldDef { FieldDefClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<dynamic[]>(reader);
                    return new FieldDef { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type FieldDef");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FieldDef)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FieldDefClass != null)
            {
                serializer.Serialize(writer, value.FieldDefClass);
                return;
            }
            throw new Exception("Cannot marshal type FieldDef");
        }

        public static readonly FieldDefConverter Singleton = new FieldDefConverter();
    }

    internal class FieldDisplayModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FieldDisplayMode) || t == typeof(FieldDisplayMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "EntityTile":
                    return FieldDisplayMode.EntityTile;
                case "Hidden":
                    return FieldDisplayMode.Hidden;
                case "NameAndValue":
                    return FieldDisplayMode.NameAndValue;
                case "PointPath":
                    return FieldDisplayMode.PointPath;
                case "PointStar":
                    return FieldDisplayMode.PointStar;
                case "RadiusGrid":
                    return FieldDisplayMode.RadiusGrid;
                case "RadiusPx":
                    return FieldDisplayMode.RadiusPx;
                case "ValueOnly":
                    return FieldDisplayMode.ValueOnly;
            }
            throw new Exception("Cannot unmarshal type FieldDisplayMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FieldDisplayMode)untypedValue;
            switch (value)
            {
                case FieldDisplayMode.EntityTile:
                    serializer.Serialize(writer, "EntityTile");
                    return;
                case FieldDisplayMode.Hidden:
                    serializer.Serialize(writer, "Hidden");
                    return;
                case FieldDisplayMode.NameAndValue:
                    serializer.Serialize(writer, "NameAndValue");
                    return;
                case FieldDisplayMode.PointPath:
                    serializer.Serialize(writer, "PointPath");
                    return;
                case FieldDisplayMode.PointStar:
                    serializer.Serialize(writer, "PointStar");
                    return;
                case FieldDisplayMode.RadiusGrid:
                    serializer.Serialize(writer, "RadiusGrid");
                    return;
                case FieldDisplayMode.RadiusPx:
                    serializer.Serialize(writer, "RadiusPx");
                    return;
                case FieldDisplayMode.ValueOnly:
                    serializer.Serialize(writer, "ValueOnly");
                    return;
            }
            throw new Exception("Cannot marshal type FieldDisplayMode");
        }

        public static readonly FieldDisplayModeConverter Singleton = new FieldDisplayModeConverter();
    }

    internal class FieldDisplayPositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FieldDisplayPosition) || t == typeof(FieldDisplayPosition?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Above":
                    return FieldDisplayPosition.Above;
                case "Beneath":
                    return FieldDisplayPosition.Beneath;
                case "Center":
                    return FieldDisplayPosition.Center;
            }
            throw new Exception("Cannot unmarshal type FieldDisplayPosition");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FieldDisplayPosition)untypedValue;
            switch (value)
            {
                case FieldDisplayPosition.Above:
                    serializer.Serialize(writer, "Above");
                    return;
                case FieldDisplayPosition.Beneath:
                    serializer.Serialize(writer, "Beneath");
                    return;
                case FieldDisplayPosition.Center:
                    serializer.Serialize(writer, "Center");
                    return;
            }
            throw new Exception("Cannot marshal type FieldDisplayPosition");
        }

        public static readonly FieldDisplayPositionConverter Singleton = new FieldDisplayPositionConverter();
    }

    internal class EntityLimitBehaviorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EntityLimitBehavior) || t == typeof(EntityLimitBehavior?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "DiscardOldOnes":
                    return EntityLimitBehavior.DiscardOldOnes;
                case "MoveLastOne":
                    return EntityLimitBehavior.MoveLastOne;
                case "PreventAdding":
                    return EntityLimitBehavior.PreventAdding;
            }
            throw new Exception("Cannot unmarshal type EntityLimitBehavior");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (EntityLimitBehavior)untypedValue;
            switch (value)
            {
                case EntityLimitBehavior.DiscardOldOnes:
                    serializer.Serialize(writer, "DiscardOldOnes");
                    return;
                case EntityLimitBehavior.MoveLastOne:
                    serializer.Serialize(writer, "MoveLastOne");
                    return;
                case EntityLimitBehavior.PreventAdding:
                    serializer.Serialize(writer, "PreventAdding");
                    return;
            }
            throw new Exception("Cannot marshal type EntityLimitBehavior");
        }

        public static readonly EntityLimitBehaviorConverter Singleton = new EntityLimitBehaviorConverter();
    }

    internal class EntityRenderModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EntityRenderMode) || t == typeof(EntityRenderMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Cross":
                    return EntityRenderMode.Cross;
                case "Ellipse":
                    return EntityRenderMode.Ellipse;
                case "Rectangle":
                    return EntityRenderMode.Rectangle;
                case "Tile":
                    return EntityRenderMode.Tile;
            }
            throw new Exception("Cannot unmarshal type EntityRenderMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (EntityRenderMode)untypedValue;
            switch (value)
            {
                case EntityRenderMode.Cross:
                    serializer.Serialize(writer, "Cross");
                    return;
                case EntityRenderMode.Ellipse:
                    serializer.Serialize(writer, "Ellipse");
                    return;
                case EntityRenderMode.Rectangle:
                    serializer.Serialize(writer, "Rectangle");
                    return;
                case EntityRenderMode.Tile:
                    serializer.Serialize(writer, "Tile");
                    return;
            }
            throw new Exception("Cannot marshal type EntityRenderMode");
        }

        public static readonly EntityRenderModeConverter Singleton = new EntityRenderModeConverter();
    }

    internal class EntityTileRenderModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EntityTileRenderMode) || t == typeof(EntityTileRenderMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Crop":
                    return EntityTileRenderMode.Crop;
                case "Stretch":
                    return EntityTileRenderMode.Stretch;
            }
            throw new Exception("Cannot unmarshal type EntityTileRenderMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (EntityTileRenderMode)untypedValue;
            switch (value)
            {
                case EntityTileRenderMode.Crop:
                    serializer.Serialize(writer, "Crop");
                    return;
                case EntityTileRenderMode.Stretch:
                    serializer.Serialize(writer, "Stretch");
                    return;
            }
            throw new Exception("Cannot marshal type EntityTileRenderMode");
        }

        public static readonly EntityTileRenderModeConverter Singleton = new EntityTileRenderModeConverter();
    }

    internal class EnumDefConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EnumDef) || t == typeof(EnumDef?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new EnumDef { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new EnumDef { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new EnumDef { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new EnumDef { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new EnumDef { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<EnumDefClass>(reader);
                    return new EnumDef { EnumDefClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<dynamic[]>(reader);
                    return new EnumDef { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type EnumDef");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (EnumDef)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.EnumDefClass != null)
            {
                serializer.Serialize(writer, value.EnumDefClass);
                return;
            }
            throw new Exception("Cannot marshal type EnumDef");
        }

        public static readonly EnumDefConverter Singleton = new EnumDefConverter();
    }

    internal class LayerDefConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LayerDef) || t == typeof(LayerDef?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new LayerDef { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new LayerDef { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new LayerDef { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new LayerDef { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new LayerDef { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<LayerDefClass>(reader);
                    return new LayerDef { LayerDefClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<dynamic[]>(reader);
                    return new LayerDef { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type LayerDef");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (LayerDef)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.LayerDefClass != null)
            {
                serializer.Serialize(writer, value.LayerDefClass);
                return;
            }
            throw new Exception("Cannot marshal type LayerDef");
        }

        public static readonly LayerDefConverter Singleton = new LayerDefConverter();
    }

    internal class AutoRuleDefConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AutoRuleDef) || t == typeof(AutoRuleDef?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new AutoRuleDef { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new AutoRuleDef { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new AutoRuleDef { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new AutoRuleDef { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new AutoRuleDef { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<AutoRuleDefClass>(reader);
                    return new AutoRuleDef { AutoRuleDefClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<dynamic[]>(reader);
                    return new AutoRuleDef { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type AutoRuleDef");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AutoRuleDef)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.AutoRuleDefClass != null)
            {
                serializer.Serialize(writer, value.AutoRuleDefClass);
                return;
            }
            throw new Exception("Cannot marshal type AutoRuleDef");
        }

        public static readonly AutoRuleDefConverter Singleton = new AutoRuleDefConverter();
    }

    internal class AutoLayerRuleCheckerModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AutoLayerRuleCheckerMode) || t == typeof(AutoLayerRuleCheckerMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Horizontal":
                    return AutoLayerRuleCheckerMode.Horizontal;
                case "None":
                    return AutoLayerRuleCheckerMode.None;
                case "Vertical":
                    return AutoLayerRuleCheckerMode.Vertical;
            }
            throw new Exception("Cannot unmarshal type AutoLayerRuleCheckerMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AutoLayerRuleCheckerMode)untypedValue;
            switch (value)
            {
                case AutoLayerRuleCheckerMode.Horizontal:
                    serializer.Serialize(writer, "Horizontal");
                    return;
                case AutoLayerRuleCheckerMode.None:
                    serializer.Serialize(writer, "None");
                    return;
                case AutoLayerRuleCheckerMode.Vertical:
                    serializer.Serialize(writer, "Vertical");
                    return;
            }
            throw new Exception("Cannot marshal type AutoLayerRuleCheckerMode");
        }

        public static readonly AutoLayerRuleCheckerModeConverter Singleton = new AutoLayerRuleCheckerModeConverter();
    }

    internal class AutoLayerRuleTileModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AutoLayerRuleTileMode) || t == typeof(AutoLayerRuleTileMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Single":
                    return AutoLayerRuleTileMode.Single;
                case "Stamp":
                    return AutoLayerRuleTileMode.Stamp;
            }
            throw new Exception("Cannot unmarshal type AutoLayerRuleTileMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AutoLayerRuleTileMode)untypedValue;
            switch (value)
            {
                case AutoLayerRuleTileMode.Single:
                    serializer.Serialize(writer, "Single");
                    return;
                case AutoLayerRuleTileMode.Stamp:
                    serializer.Serialize(writer, "Stamp");
                    return;
            }
            throw new Exception("Cannot marshal type AutoLayerRuleTileMode");
        }

        public static readonly AutoLayerRuleTileModeConverter Singleton = new AutoLayerRuleTileModeConverter();
    }

    internal class LayerTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LayerType) || t == typeof(LayerType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AutoLayer":
                    return LayerType.AutoLayer;
                case "Entities":
                    return LayerType.Entities;
                case "IntGrid":
                    return LayerType.IntGrid;
                case "Tiles":
                    return LayerType.Tiles;
            }
            throw new Exception("Cannot unmarshal type LayerType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LayerType)untypedValue;
            switch (value)
            {
                case LayerType.AutoLayer:
                    serializer.Serialize(writer, "AutoLayer");
                    return;
                case LayerType.Entities:
                    serializer.Serialize(writer, "Entities");
                    return;
                case LayerType.IntGrid:
                    serializer.Serialize(writer, "IntGrid");
                    return;
                case LayerType.Tiles:
                    serializer.Serialize(writer, "Tiles");
                    return;
            }
            throw new Exception("Cannot marshal type LayerType");
        }

        public static readonly LayerTypeConverter Singleton = new LayerTypeConverter();
    }

    internal class TilesetDefConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TilesetDef) || t == typeof(TilesetDef?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new TilesetDef { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new TilesetDef { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new TilesetDef { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new TilesetDef { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new TilesetDef { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TilesetDefClass>(reader);
                    return new TilesetDef { TilesetDefClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<dynamic[]>(reader);
                    return new TilesetDef { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TilesetDef");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TilesetDef)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.TilesetDefClass != null)
            {
                serializer.Serialize(writer, value.TilesetDefClass);
                return;
            }
            throw new Exception("Cannot marshal type TilesetDef");
        }

        public static readonly TilesetDefConverter Singleton = new TilesetDefConverter();
    }

    internal class LevelConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Level) || t == typeof(Level?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new Level { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new Level { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Level { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Level { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Level { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<LevelClass>(reader);
                    return new Level { LevelClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<dynamic[]>(reader);
                    return new Level { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Level");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Level)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.LevelClass != null)
            {
                serializer.Serialize(writer, value.LevelClass);
                return;
            }
            throw new Exception("Cannot marshal type Level");
        }

        public static readonly LevelConverter Singleton = new LevelConverter();
    }

    internal class LayerInstanceConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LayerInstance) || t == typeof(LayerInstance?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new LayerInstance { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new LayerInstance { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new LayerInstance { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new LayerInstance { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new LayerInstance { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<LayerInstanceClass>(reader);
                    return new LayerInstance { LayerInstanceClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<dynamic[]>(reader);
                    return new LayerInstance { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type LayerInstance");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (LayerInstance)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.LayerInstanceClass != null)
            {
                serializer.Serialize(writer, value.LayerInstanceClass);
                return;
            }
            throw new Exception("Cannot marshal type LayerInstance");
        }

        public static readonly LayerInstanceConverter Singleton = new LayerInstanceConverter();
    }

    internal class TileConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Tile) || t == typeof(Tile?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new Tile { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new Tile { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Tile { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Tile { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Tile { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TileClass>(reader);
                    return new Tile { TileClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<dynamic[]>(reader);
                    return new Tile { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Tile");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Tile)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.TileClass != null)
            {
                serializer.Serialize(writer, value.TileClass);
                return;
            }
            throw new Exception("Cannot marshal type Tile");
        }

        public static readonly TileConverter Singleton = new TileConverter();
    }

    internal class EntityInstanceConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EntityInstance) || t == typeof(EntityInstance?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new EntityInstance { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new EntityInstance { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new EntityInstance { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new EntityInstance { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new EntityInstance { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<EntityInstanceClass>(reader);
                    return new EntityInstance { EntityInstanceClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<dynamic[]>(reader);
                    return new EntityInstance { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type EntityInstance");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (EntityInstance)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.EntityInstanceClass != null)
            {
                serializer.Serialize(writer, value.EntityInstanceClass);
                return;
            }
            throw new Exception("Cannot marshal type EntityInstance");
        }

        public static readonly EntityInstanceConverter Singleton = new EntityInstanceConverter();
    }

    internal class FieldInstanceConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FieldInstance) || t == typeof(FieldInstance?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new FieldInstance { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new FieldInstance { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new FieldInstance { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new FieldInstance { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new FieldInstance { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FieldInstanceClass>(reader);
                    return new FieldInstance { FieldInstanceClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<dynamic[]>(reader);
                    return new FieldInstance { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type FieldInstance");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FieldInstance)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FieldInstanceClass != null)
            {
                serializer.Serialize(writer, value.FieldInstanceClass);
                return;
            }
            throw new Exception("Cannot marshal type FieldInstance");
        }

        public static readonly FieldInstanceConverter Singleton = new FieldInstanceConverter();
    }
}
